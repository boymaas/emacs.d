#+TITLE: Evil setup
#+OPTIONS: toc:2 num:nil ^:nil

* El-get packages
  :PROPERTIES:
  :CUSTOM_ID: core-packages
  :END:

#+NAME: core-packages
#+CAPTION: El-get packages matrix for ome-advanced module
|                  | Status      | Description                                   |
|------------------+-------------+-----------------------------------------------|
| [[http://gitorious.org/evil][evil]]             | Required    | Finally, the Emacs OS get a good editor.      |
| [[https://github.com/cofi/evil-leader][evil-leader]]      | Required    | <leader> key for evil.                        |
| [[https://github.com/timcharper/evil-surround][evil-surround]]    | Recommended | Surround.vim for evil.                        |
| [[https://github.com/magnars/expand-region.el][expand-region.el]] | Recommended | Expand and select.                            |
| [[https://github.com/jhelwig/ack-and-a-half][ack-and-a-half]]   | Recommended | Yet another emacs front-end to ack.           |
| [[https://github.com/winterTTr/ace-jump-mode][ace-jump-mode]]    | Recommended | A quick cursor location minor mode for emacs. |

* Evil
  :PROPERTIES:
  :CUSTOM_ID: evil
  :END:

#+BEGIN_QUOTE
As a poke at Emacs' creeping featurism, vi advocates have been known to
describe Emacs as "a great operating system, lacking only a decent editor".

-- [[http://en.wikipedia.org/wiki/Editor_war][Editor war]]
#+END_QUOTE

If you need to turn off evil temporarily for a single buffer, use
=M-x evil-local-mode= instead of =M-x evil-mode=, since the latter will turn
off evil-mode globally, which means, evil-mode will be turned off for the whole
Emacs session.


#+NAME: evil
#+BEGIN_SRC emacs-lisp
(defun bmaas/evil-setup ()
  (setq evil-auto-indent t)
  (setq evil-regexp-search t)
  (setq evil-want-C-i-jump t)
  ;; normal redo key
  (global-set-key (kbd "C-r") 'undo-tree-redo)

  (add-hook 'text-mode-hook 'turn-on-evil-mode)
  (add-hook 'prog-mode-hook 'turn-on-evil-mode)
  (add-hook 'comint-mode-hook 'turn-on-evil-mode)
  (add-hook 'Info-mode-hook 'turn-off-evil-mode))


(bmaas/install 'evil 'bmaas/evil-setup)


#+END_SRC

* Evil state based modeline color

Colored modeline, for easy determiniation of mode we are in.
Got this from emacs-wiki as a snippet.

#+begin_src emacs-lisp :tangle yes
;; change mode-line color by evil state
(defvar bmaas/default-modeline-color (cons (face-background 'mode-line)
                                           (face-foreground 'mode-line)))

(defun bmaas/change-modeline-color-on-buffer-state ()
  (let ((color (cond ((minibufferp) bmaas/default-modeline-color)
                     ((evil-insert-state-p) '("black" . "#cccccc"))
                     ((evil-emacs-state-p)  '("black" . "blue"))
                     ((evil-motion-state-p)  '("black" . "Yellow"))
                     ;;((buffer-modified-p)   '("#006fa0" . "#cccccc"))
                     (t bmaas/default-modeline-color))))
    (set-face-background 'mode-line (car color))
    (set-face-foreground 'mode-line (cdr color))))

(add-hook 'post-command-hook 'bmaas/change-modeline-color-on-buffer-state)
#+end_src

* Evil-leader
  :PROPERTIES:
  :CUSTOM_ID: evil-leader
  :END:

Evil leader just provides the =<leader>= feature from Vim to evil, which
provides an easy way to bind keys under a variable prefix key. The default
binding of =<leader>= is =\=, which is not easy to reach, so I bind
it to =;=.

My choice for =;= has some limitations, since the =C-;= combination will
not be send by some terminals. Which has to do with the =modifyOtherKeys=
extention which has been introduced in later terminal implemenations.

iTerm2 which I use will not send the C-; combination.

http://manytricks.com/keycodes/ has an app to find
keycodes for your system.

#+NAME: evil-leader
#+BEGIN_SRC emacs-lisp
(defun bmaas/evil-leader-setup ()
  (evil-leader/set-leader ";")

  ; enable in all states
  (setq evil-leader/non-normal-prefix "C-")
  (setq evil-leader/in-all-states t)

  (unless (featurep 'helm)
    (evil-leader/set-key
      "e" 'find-file
      "b" 'switch-to-buffer))
  (eval-after-load "helm"
    (evil-leader/set-key
      "f" 'projectile-find-file
      "F" 'helm-find-files
      "F" 'helm-for-files

      "hl" 'helm-locate
      ;;"c" 'helm-colors
      "y" 'helm-show-kill-ring
      "ht" 'helm-top
      "hm" 'helm-man-woman
      "ha" 'helm-apropos
      "hr" 'helm-resume
      "hb" 'helm-bookmarks

      "x" 'helm-M-x
      ;;"X" 'smex

      "b" 'ido-switch-buffer

      ;; todo: maybe this can be done with advise?
      "eb" (lambda ()
             (interactive)
             (if (fboundp 'bmaas/persp-ibuffer)
                          (bmaas/persp-ibuffer)
                        (ibuffer)))
      "B" 'helm-buffers-list

      ;; custom
      ";" 'evil-buffer

      "el" (lambda () (interactive)
             (dired "."))

      ;;"c" 'evilnc-comment-or-uncomment-lines
      ))
  (eval-after-load "persp-mode"
    (evil-leader/set-key
      "ws" 'persp-switch
      "wkb" 'persp-remove-buffer
      "wab" 'persp-add-buffer
      "wS" 'persp-save-state-to-file
      "wL" 'persp-load-state-from-file
      "wK" 'persp-kill
      "wI" 'persp-import-buffers
      ))
  (eval-after-load "projectile"
    (evil-leader/set-key
      "p4f" 'projectile-find-file-other-window
      "p4t" 'projectile-find-implementation-or-test-other-window
      "pf" 'projectile-find-file
      "pT" 'projectile-find-test-file
      "pl" 'projectile-find-file-in-directory
      "pt" 'projectile-toggle-between-implementation-and-test
      "pg" 'projectile-grep
      "p4b" 'projectile-switch-to-buffer-other-window
      "pb" 'projectile-switch-to-buffer
      "po" 'projectile-multi-occur
      "pr" 'projectile-replace
      "pi" 'projectile-invalidate-cache
      "pR" 'projectile-regenerate-tags
      "pj" 'projectile-find-tag
      "pk" 'projectile-kill-buffers
      "pd" 'projectile-find-dir
      "pD" 'projectile-dired
      "pv" 'projectile-vc-dir
      "pe" 'projectile-recentf
      "pa" 'projectile-ack
      "pA" 'projectile-ag
      "pc" 'projectile-compile-project
      "pp" 'projectile-test-project
      "pz" 'projectile-cache-current-file
      "ps" 'projectile-switch-project
      "pm" 'projectile-commander
      "ph" 'helm-projectile
      ))
  (eval-after-load "org-mode"
    (evil-leader/set-key
      "oa" 'org-agenda
      "oo" 'org-open-at-point
      "ols" 'org-store-link
      "oli" 'org-insert-link
      ))
  (eval-after-load "yasnippet"
    (evil-leader/set-key
      "is" 'yas-insert-snippet))
  (eval-after-load "expand-region"
    (progn
      (setq expand-region-contract-fast-key "z")
      (evil-leader/set-key "X" 'er/expand-region)))
  (eval-after-load "magit"
    (evil-leader/set-key "g" 'magit-status))
  (eval-after-load "smartparens"
    (evil-leader/set-key
      "sf" 'sp-forward-sexp
      "sb" 'sp-backward-sexp

      "sd" 'sp-down-sexp
      "sD" 'sp-backward-down-sexp
      "sa" 'sp-beginning-of-sexp
      "se" 'sp-end-of-sexp

      "su" 'sp-up-sexp
      ;; (define-key emacs-lisp-mode-map (kbd ")") 'sp-up-sexp)
      "sU" 'sp-backward-up-sexp
      "st" 'sp-transpose-sexp

      "sn" 'sp-next-sexp
      "sp" 'sp-previous-sexp

      "sk" 'sp-kill-sexp
      "sy" 'sp-copy-sexp

      "ss" 'sp-forward-slurp-sexp
      "sr" 'sp-forward-barf-sexp
      "sS" 'sp-backward-slurp-sexp
      "sR" 'sp-backward-barf-sexp
      "sF" 'sp-forward-symbol
      "sB" 'sp-backward-symbol

      "s[" 'sp-select-previous-thing
      "s]" 'sp-select-next-thing

      ;; (define-key sp-keymap (kbd "M-s M-i") 'sp-splice-sexp)
      ;; (define-key sp-keymap (kbd "M-s <delete>") 'sp-splice-sexp-killing-forward)
      ;; (define-key sp-keymap (kbd "M-s <backspace>") 'sp-splice-sexp-killing-backward)
      ;; (define-key sp-keymap (kbd "M-s M-<backspace>") 'sp-splice-sexp-killing-around)

      "swd" 'sp-unwrap-sexp
      "swb" 'sp-backward-unwrap-sexp

      "smt" 'sp-prefix-tag-object
      "smp" 'sp-prefix-pair-object
      "smc" 'sp-convolute-sexp
      "sma" 'sp-absorb-sexp
      "sme" 'sp-emit-sexp
      "smp" 'sp-add-to-previous-sexp
      "smn" 'sp-add-to-next-sexp
      "smj" 'sp-join-sexp
      "sms" 'sp-split-sexp
      "smr" 'sp-raise-sexp
      ))
  (evil-leader/set-key
    "'" 'comment-region
    "k" 'kill-buffer)
  (global-evil-leader-mode)
  ;; Messages buffer does not get the leader because
  ;; it exists already. We just kill it so it opens again
  (kill-buffer "*Messages*")
)

(bmaas/install 'evil-leader 'bmaas/evil-leader-setup)
#+END_SRC

* Evil-everywhere - evil-mode integration

We prefer to be in evil mode in all kinds of buffers. Searching google I
encountered[[https://gitorious.org/evil/evil/source/8a9aeae5db3bbb19d2349b7de86d8de3c151e123:evil-integration.el][ Evil repos - integration]] which gives some hints on how to integrate.

** TODO Emacs states to motion states

So to get the integration I want I move all the "emacs states" to the
evil-motion states. Then I move some common keys from the motion state map
to the normal state map so they won't conflict with normal behaviour.

Some buffers we don't want motion mode, like the buffers with composed
keymaps such as the magit-key-mode. Here we want to force emacs state.

For this it has to be removed from the motions-states list and added to
the emacs list state.

You can add these specific modes the the =bmaas/evil-emacs-state-modes=.

To add extra modes to the motions states just add entries to the variable
=bmaas/evil-motion-state-modes=.

#+begin_src emacs-lisp :tangle yes
(defvar bmaas/evil-emacs-state-modes)
(defvar bmaas/evil-motion-state-modes)
(defvar bmaas/evil-overriding-mode-maps)

(setq bmaas/evil-emacs-state-modes '(magit-key-mode
                                     magit-process-mode
                                     magit-branch-manager-mode
                                     org-agenda-mode
                                     custom-mode))

(setq bmaas/evil-motion-state-modes '(dired-mode))

(setq bmaas/evil-overriding-mode-maps (list dired-mode-map
                                        ;...
                                            ))

(defun bmaas/move-key (keymap-from keymap-to key)
  "Moves key binding from one keymap to another and delete from the old location. "
  (define-key keymap-to key (lookup-key keymap-from key))
  (define-key keymap-from key nil))

(eval-after-load 'evil
  '(progn
     ;; all emacs mode modes beome motion modes
     (setq evil-motion-state-modes (append evil-emacs-state-modes
                                           evil-motion-state-modes
                                           bmaas/evil-motion-state-modes))
     (setq evil-emacs-state-modes '())

     ;; except for several modes we want to keep emacs
     (dolist (a-mode  bmaas/evil-emacs-state-modes)
           (setq evil-motion-state-modes (delq a-mode evil-motion-state-modes))
           (add-to-list 'evil-emacs-state-modes a-mode))

     ;; make overriding map defined modes
     (dolist (a-mode-map bmaas/evil-overriding-mode-maps)
       (evil-make-overriding-map a-mode-map 'motion))


     ;; move many caught keys to normal map
     (bmaas/move-key evil-motion-state-map evil-normal-state-map (kbd "RET"))
     (bmaas/move-key evil-motion-state-map evil-normal-state-map " ")

     ;; needed to activate settings
     (evil-mode)))
#+end_src

** Ibuffer overrides

#+begin_src emacs-lisp :tangle yes
(eval-after-load 'ibuffer
  '(progn
    (evil-make-overriding-map ibuffer-mode-map 'motion)))
#+end_src

** Magit overrides

Enter motion mode as specified above, but make the magit-mode-map override,
the default motion keys.

#+begin_src emacs-lisp :tangle yes
(eval-after-load 'magit
  '(evil-make-overriding-map magit-mode-map 'motion))
#+end_src

** Dired overrides

Dired seems to go to evil-normal mode. I want it to be motion state!

Does not work, since enter is not functioning in motion state ..

#+begin_src emacs-lisp :tangle no
(defun bmaas/force-evil-motion-state ()
  (evil-motion-state))

(add-hook 'dired-mode-hook 'bmaas/force-evil-motion-state)
#+end_src

** TODO this is probably more reasonable
  https://github.com/prooftechnique/.emacs.d/blob/master/config/jhenahan-evil.el
  https://github.com/edwtjo/evil-org-mode

* Evil-surround
  :PROPERTIES:
  :CUSTOM_ID: evil-surround
  :END:

As I said, =smartparens= is the ultimate pair management solution for
Emacs. So why [[https://github.com/timcharper/evil-surround][evil-surround]]?

[[https://github.com/timcharper/evil-surround][evil-surround]] is a port of [[https://github.com/tpope/vim-surround][vim-surround]] to evil. I think you can treat
=evil-surround= as a complement of =smartparens= in pair changing, deleting
and adding, while =smartparens= is good at pair inserting and operating.

IMHO, no editors can compete with Vim in pure text editing speed. So I
think =evil-surround= is still worth a try. [[http://www.catonmat.net/blog/vim-plugins-surround-vim/][Here]] is an excellent and concise
tutorial for =vim-surround=. Note that there may be some minor differences
between =evil-surround= and =vim-surround=. However, for daily use, they're
almost the same.

#+NAME: evil-surround
#+BEGIN_SRC emacs-lisp
(bmaas/install 'evil-surround 'bmaas/noop)
#+END_SRC

* Ace-jump-mode
  :PROPERTIES:
  :CUSTOM_ID: ace-jump-mode
  :END:

[[https://github.com/winterTTr/ace-jump-mode][ace-jump-mode]] is a minor mode for Emacs, enabling fast/direct cursor movement
in current view. "You can move your cursor to ANY position (across window and
frame) in emacs by using only 3 times key press."

To tell the truth, I still don't why it it called "ace-jump". Seems [[https://github.com/johnlindquist/AceJump][AceJump]]
first appears as an [[http://www.jetbrains.com/idea/][Intellij]] [[http://plugins.jetbrains.com/plugin/7086?pr%3DphpStorm][plugin]]. [[http://www.vim.org/scripts/script.php?script_id%3D3526][EasyMotion]] provides a similar feature to Vim.

Oh-my-emacs adopt [[https://github.com/cofi/evil-leader][evil-leader]] and bind serveral keys to ace-jump-mode commands:
- =<Leader> c=: =ace-jump-char-mode=
- =<Leader> w=: =ace-jump-word-mode=
- =<Leader> l=: =ace-jump-line-mode=

#+NAME: ace-jump-mode
#+BEGIN_SRC emacs-lisp
(defun bmaas/ace-jump-mode-setup ()
  (when (and (featurep 'evil) (featurep 'evil-leader))
    (evil-leader/set-key
      "c" 'ace-jump-char-mode
      "w" 'ace-jump-word-mode
      "l" 'ace-jump-line-mode)))

(bmaas/install 'ace-jump-mode 'bmaas/noop)
#+END_SRC

* Ack-and-a-half
  :PROPERTIES:
  :CUSTOM_ID: ack-and-a-ha
  :END:

As we all know, Emacs is a good text editor. However, in some cases, we may
spend most of our time to text reading instead of editing. As an advanced Emacs
user, you may know [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Grep-Searching.html][grep-find]], and you may also know that you can jump to the
next matching item by =M-g n=, oh, that's cool, really. But you still need to
specify what type of file to search. You don't want to touch binary files with
Emacs, ha? And, certainly you do want to ignore some hidden files such as files
and directories used by various version control system. So there comes [[http://beyondgrep.com/][ack]],
which works as expected.

With the help of [[https://github.com/jhelwig/ack-and-a-half][ack-and-a-half]], just go to the right place, then =M-x ack=,
you'll get all you need. Enjoy it.

#+NAME: ack-and-a-half
#+BEGIN_SRC emacs-lisp
(when (or (executable-find "ack") (executable-find "ack-grep"))
  (bmaas/install 'ack-and-a-half 'bmaas/noop))
#+END_SRC

* ag
  :PROPERTIES:
  :CUSTOM_ID: ag
  :END:

ag, [[https://github.com/ggreer/the_silver_searcher][the silver searcher]], a code searching tool similar to [[http://beyondgrep.com/][ack]] but much more
faster. It searches code abot 3-5x faster than ack, and "The command name is
33% shorter than ack, and all keys are on the home row!". I've used it for
serveral months and it's amazing.

[[https://github.com/bbatsov/projectile][Projectile]] has builtin support for ag(=projectile-ag=) via =C-c p A=.

#+NAME: ag
#+BEGIN_SRC emacs-lisp
(when (executable-find "ag")
  (bmaas/install 'ag 'bmaas/noop))
#+END_SRC
