#+TITLE: Clojure
#+OPTIONS: toc:2 num:nil ^:nil

* Clojure
  :PROPERTIES:
  :CUSTOM_ID: clojure
  :END:

[[http://www.clojure.org][Clojure]] is a modern Lisp on top of JVM, it is a member of the Lisp family of
languages. Clojure extends the code-as-data system beyond parenthesized lists
(s-expressions) to vectors and maps.

#+NAME: clojure
#+BEGIN_SRC emacs-lisp
(bmaas/install 'clojure-mode 'bmaas/noop)

(defun bmaas/cider-setup ()
  (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
  (setq cider-repl-tab-command 'indent-for-tab-command)
  (setq cider-repl-pop-to-buffer-on-connect nil)
  (setq cider-popup-stacktraces t)
  (setq cider-repl-popup-stacktraces t)
  (setq cider-auto-select-error-buffer t)
  (setq nrepl-hide-special-buffers t)
  (setq nrepl-buffer-name-separator "-")
  (setq nrepl-buffer-name-show-port t)

  ;; TODO: find cider-repl
  ;; (eval-after-load "cider-repl-mode"
  ;;   (define-key cider-repl-mode-map (kbd "C-l") 'cider-repl-clear-buffer))
)

(bmaas/install 'cider 'bmaas/cider-setup)
#+END_SRC

* Clojure Refector clj-refactor

A collection of simple clojure refactoring functions.

#+begin_src emacs-lisp :tangle yes
(defun bmaas/clj-refactor-setup ()
  (add-hook 'clojure-mode-hook (lambda ()
                                 (clj-refactor-mode 1)))

  (evil-leader/set-key-for-mode 'clojure-mode
    "rrf" 'cljr-rename-file
    "rru" 'cljr-replace-use
    "rau" 'cljr-add-use-to-ns
    "rar" 'cljr-add-require-to-ns
    "rai" 'cljr-add-import-to-ns
    "rsn" 'cljr-sort-ns
    "rrr" 'cljr-remove-unused-requires
    "rsr" 'cljr-stop-referring
    "rth" 'cljr-thread
    "ruw" 'cljr-unwind
    "rua" 'cljr-unwind-all
    "ril" 'cljr-introduce-let
    "rel" 'cljr-expand-let
    "rml" 'cljr-move-to-let
    "rmf" 'cljr-move-form
    "rtf" 'cljr-thread-first-all
    "rtl" 'cljr-thread-last-all
    "rcp" 'cljr-cycle-privacy
    "rcc" 'cljr-cycle-coll
    "rcs" 'cljr-cycle-stringlike
    "rci" 'cljr-cycle-if
    "rad" 'cljr-add-declaration
    "rdk" 'cljr-destructure-keys
    "rpc" 'cljr-project-clean)
  )

(bmaas/install 'clj-refactor 'bmaas/clj-refactor-setup)

#+end_src


* Normal keybindings

Cider jump is disabled by a evil-mode mapping to evil-repeat function
there are many ways to fix this. One is to rebind the M-. to the cider jump
functoin, which would leave this mapping in place in all other normal modes.

Another would be to insert a custom keymap in the emulation mode maps, which
is a lot of work and would override the mapping also for every binding.

Simplest way is just to clear the binding by setting it to =nil= in the
evil-normal-state-map.

#+begin_src emacs-lisp :tangle yes
(defun bmaas/cider-local-keys ()
  (define-key evil-normal-state-map (kbd "M-.") nil))

(add-hook 'cider-mode-hook 'bmaas/cider-local-keys)
(add-hook 'clojure-mode-hook 'bmaas/cider-local-keys)

#+end_src

* Evil keybindings

  Notice we are setting mode local bindings, so ;c stays available for
  others. The locals will override the normal leaders

#+begin_src emacs-lisp :tangle yes
(evil-leader/set-key-for-mode 'clojure-mode
  "cj" 'cider-jack-in
  "cqq" 'cider-quit
  "cqr" 'cider-restart
  "cef" 'cider-load-file
  "ceb" 'cider-eval-buffer
  "cer" 'cider-eval-region
  "cl" 'cider-load-file
  "cele" 'cider-eval-last-sexp
  "celp" 'cider-pprint-eval-last-sexp
  "celr" 'cider-eval-last-sexp-and-replace
  "cc" 'cider-eval-defun-at-point
  "cr" 'cider-switch-to-repl-buffer
  "cn" 'cider-repl-set-ns
  "cd" 'cider-doc
  "ci" 'cider-inspect
  "cm" 'cider-macroexpand-1
  "cM" 'cider-macroexpand-all
  "." 'clojure-jump-between-tests-and-code
  "t" 'clojure-test-run-tests
  "T" 'clojure-test-run-test
  )
#+end_src
